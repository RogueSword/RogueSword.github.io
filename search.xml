<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019面试资料整理]]></title>
    <url>%2F2019%2F09%2F19%2F2019%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[综合 五分钟面试 学习路线以及方向的总结 js 关于隐式转换 宏任务与微任务 vue vue生命周期 Vue 面试中常问知识点整理 面试必备的13道可以举一反三的Vue面试题 「从源码中学习」面试官都不知道的Vue题目答案 30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度） Vue.js最佳实践（五招让你成为Vue.js大师 vm.$attrs 【Vue 2.4.0新增inheritAttrs，attrs详解】 面试官：你了解 vue 的diff算法吗？ Vuejs建议和最佳实践 webpack 配置 eslint 配置 webpack中对于输出文件名可以有三种hash值 http HTTP协议【详解】——经典面试题 针对同样的路由，携带了动态参数， /path/a /path/b，解决不刷新的问题 watch中观察$route, handler为请求的方法名，immediate 设置为 true beforeRouteUpdate 路由守卫解决 在 router-view里面新增1&lt;router-view :key=&quot;$route.fullpath&quot;&gt;&lt;/router-view&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[commonJS和ES6模块化]]></title>
    <url>%2F2018%2F08%2F30%2FcommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[随js语言持续优化，为我们的开发带来较大的便利性。但是在使用node和es6的模块化功能时候，两者的使用方式还是有点区别。在这里做一小结，以便日后查阅 基本的使用规范CommonJS 主要是Node.js的使用规范， 每一个js都是一个独立的模块，并且里面的变量名称互不冲突。使用规则为一个模块向外导出变量，另一个模块导入变量 语法 导出的模块：module.exports = ‘变量名’ 导入的模块：var newName = require(‘./导出模块的路径’); 注意使用事项：由于导出的写法不同，因此导入后的使用方式也不通具体如下123456789101112131415161718192021222324252627282930&lt;!-- 写法一 --&gt;// export.jsvar a = 'Shen Zhen';function greet(name) &#123; console.log(`welcome $&#123;name&#125;, $&#123;a&#125;`);&#125;module.exports = greet;// import.jsvar a = 'Roy';var method = require('./export.js');method(a); // 直接将引入的方法调用&lt;!-- 写法2 --&gt;// export.jsmodule.exports = &#123; greet: greet&#125;// import.jsvar obj = require('./export.js'); // 此时引入的是个对象，因此需要对对象的调用obj.greet(a);&lt;!-- 写法3：不推荐，容易混淆 --&gt;// export.jsexports.greet = greet;// import.jsvar obj = require('./export.js'); // 此时引入的是个对象，因此需要对对象的调用obj.greet(a); 注意：在写法2和3中，我们可以看到，两者导出的均为一个对象。实际上在node中，module.exports和exports是同一个变量，并且初始化为一个空对象{}。在这个空对象中，可以存放键值对形式的方法。但是如果要导出的是数组或者函数，则必须使用module.exports，实际上，记住一点即可，使用module.exports总是不会错的！ 其他：对于引用node的一些内置模块时，可以直接引用其模块名称1234const http = require('http');http.createServer((request, response) =&gt; &#123;&#125;).listen('8080') ES6模块化 常见的几种写法 直接export导出。es6将其视为一个模块,export分别对外将变量导出 12345678910// export.js// 也可以写做连续声明变量的形式，去掉第二个export字段，在第一个最后写上','export var name = 'Roy';export function getName(name) &#123; console.log(name);&#125;// import.jsimport &#123;name, getName&#125; from './export.js'getName(); 先正常定义，后导出。推荐此方法，清晰明了 123456789// export.jsconst name = 'Roy';let getName = function (name) &#123; console.log(name);&#125;// import.jsexport &#123;name, getName&#125;; getName(); export导出时候，可以将导出的变量重命名后再导出 123456789// export.jsconst name = 'Roy';let getName = function() &#123; console.log(name);&#125;export &#123; name as nn, getName as get&#125; import导入的时候，可以将导入的变量重命名 12345// import.js// 注意导入的模块名必须和导出时写的变量名一致，同时导入后的模块只读，只能使用，不可再做修改重定义。但是，当且导出的是个对象，导入的js里面可以修改对象的属性，同时也改变了原始处的值。不推荐使用// 导入时候地址可以相对路径，也可以绝对路径，// 导入时.js后缀可以省略import &#123;getName as getMethod&#125; from './export.js' 设置模块中转站js，匿名转载他处的变量。export2中仅作为中转站，在它里面是无法使用export1.js导出的变量 12345678910// export1.jsexport let name = 'name', getName = function() &#123;&#125;;// export2.jsexport * from './export1.js' // export &#123;name, getName&#125; from './export1.js'// import.jsimport &#123;name, getName&#125; from './export2.js'console.log(name);console.log(getName()); 终极简化1 -&gt; import整体引入,用替代具体的变量名，同时将其重命名。export 命令会忽略export模块的default方法 1234567// export.jsexport var name = 'Roy', function getName() &#123;&#125;;// import.jsimport * as obj from './export.js';obj.name; // &gt; Royobj.getName(); // 终极简化2 -&gt; export default xxx后，在import时就无需将导入的变量名与导出的保持一致了，用户可以随意命名。实际上export default就是输出了一个叫做default的变量或者方法,然后系统允许在引入它的时候改写为任何名字 123456// export.jsvar name = 'Roy';export default name;// import.js - 注意此处引入时候无需&#123;&#125;import nnn from './export.js' 小结：导出普通变量和函数的小结。注意接口名和内不变量之间要有一一对应关系 1234567891011121314// 普通变量 - 1export var m = 1;// 普通变量 - 2var m = 1;export &#123;m&#125;;// 普通变量 - 3var m = 1;export &#123;m as n&#125;;// 函数 - 1export function getName() &#123;&#125;// 函数 - 2function getName() &#123;&#125;export &#123;getName&#125; 区别 CommonJS输出的是一个值的拷贝；ES6输出的是值的引用 CommonJS是模块运行时加载；ES6是编译时完成模块加载，效率更高 参考： 廖雪峰-js教程 js当中CommonJS 和es6的模块化引入方案以及比较 ES6新特性：使用export和import实现模块化 阮一峰-ES6模块化]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git日常命令]]></title>
    <url>%2F2018%2F08%2F25%2Fgit%E6%97%A5%E5%B8%B8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git提交代码常规Git add的几种区别 git add .提交被修改(modified)文件和新文件(new)，不包括被删除(deleted)文件 git add -u =&gt; git add –update提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add -A =&gt; git add –all提交所有变化 git使用说明 场景：新增功能，使用新的分支开发1234567891011121314151617181. 在github或码云中，新建分支，输入新分支名称,如： index-swiper2. 打开项目，cd至项目文件根目录 git pull：拉分支代码至本地3. 切换新的分支 git checkout index-swiper4. 新的分支上开发5. 提交代码（本地index-swiper =&gt; 远程index-swiper） git add -A 提交在本地暂存空间 git commit -m &apos;本次提交的说明&apos; git push 将本地分支代码提交至远程分支6. 切换至本地的master分支 git checkout master7. 将线上的index-swiper分支内容与本地的master合并 git merge origin/index-swiper8. 将本地master的代码提交至远程master git push9. 显示git的修改日志 git log --pretty=oneline 删除git远程文件或者文件夹123456// 是否下载指定的分支，否则则是默认的master分支，如果没有设置setting的default分支git clone git@github.com:RogueSword/RogueSword.github.io.gitgit clone -b next git@github.com:RogueSword/RogueSword.github.io.gitgit rm theme/test.txt // 删除一级目录下的test文件的操作git rm -r theme // 删除一级目录下的theme文件夹 删除本地及远程分支123451. 删除远程分支 git push origin :BranchName git push origin -D BranchName2. 删除本地分支 git branch -D BranchName git的几种撤销+git push撤销123456789101112131415161718192021221. git add 的撤销 git status 先看一下add 中的文件 git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了2. git commit 的撤销 git log 查看节点 git reset commit_id3. git push的撤销 git revert HEAD git revert HEAD 撤销前一次 commit git revert HEAD^ 撤销前前一次 commit // 方法2 git log // 查看提交信息，以便找到会退的版本号码 git reset --soft 版本号 // 保留当前工作区，以便重新提交 --hard 版本号 // 撤销相应工作区的修改 git log // 查看当前的提交信息，确认是否已经回退 git push origin master –force // 强制提交当前版本号，以达到撤销版本号的目的。必须添加参数force进行强制提交，否则会提交失败 // 接着常规操作 git add . git commit -m &apos;xxx&apos; git push origin xxx git pull详细示例 定义： 从另一个存储库或本地分支获取并集成（整合）。取回远程某个分支的更新，再与本地的指定分支合并 语法：git pull [options] [[…]] 白话：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 1234567891011121314151617示例：1. 取回远程分支next，并与本地分支master合并 git pull origin next:master2. 取回远程分支next，并与本地当前的分支合并 git pull origin next2.1 拓展实质 上述表示取回origin/next分支，再与当前分支合并。实质上等同于先做git fetch, 再执行git merge git fetch origin git merge origin/next3. 拓展：在git中，git会自动在本地分支和远程分支之间，建立一种追踪关系。比如，git clone的时候，所有本地的分支默认与远程主机的同名分支，建立追踪关系，即本地master分支，自动追踪远程origin/master分支3.1 当然也可以手动建立追踪关系。指定本地master分支追踪远程origin/next分支 git branch --set-upstream master origin/next3.2 如果当前分支与远程分支存在追踪关系，git pull可以省略远程分支名 git pull origin3.3 如果当前分支只有一个追踪分支，可以省略主机名 git pull 快速上手git初始化五连1234567git init (初始化本地仓库)git add . （将本地所有文件加到仓库里）git commit -m &quot;message&quot; （设置提交信息）git remote add origin git@github.com:sunningcarryhaha/flexSupplement.git（本地仓库链接远程仓库）git push -u origin master （push文件到仓库中）git push --set-upstream origin master 其他易错点git pull 和 git merge的区别 git fetch 是指从远程获取最新版本到本地，不会自动合并 在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。 1234示例-写法1：git fetch origin master // 远程分支取回git log -p master..origin/master // 对比本地master与远程master区别git merge origin/master // 将fetch放在存储库里的内容与本地工作区合并 查看远程分支121. git branch -r // 查看当前远程分支2. git branch -a // 查看所有分支，远程及本地 创建.gitignore文件，忽略git不必要提交文件12345touch .gitignore // 创建.gitignore文件// 在文件录入：.deploy_git/node_modules/public/ 参考： Git-SSH文章链接 Git命令详解]]></content>
  </entry>
  <entry>
    <title><![CDATA[读书笔记《你不知道的Javascript》]]></title>
    <url>%2F2018%2F08%2F25%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Javascript%E3%80%8B(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[去年的某时在群内听闻此书名，不以为然。想来也是和普通的书本无异，这段日子又在GitHub上面看到了开源文档，star数目不小。下载下来电子版，看了一小节原型链，不禁耳目一新，真可谓打通任督二脉。话不多说，立马当当下单开啃。在此记录下学习笔记，以供日后回读。 语法新特性Number.EPSILON（ES6） - 可接受的误差范围Number.EPSILON是ES新特性，表示1和大于1的最小浮点数的差值，值为Math.pow(2, -52);可以用作测试值是否相等 实例：验证0.1 + 0.2 = 0.3。 说明：鉴于js遵循IEEE754规范，属于二进制浮点数的最大问题，就是0.1和0.2不够准确，相加之后会得到一个很接近的一个数字0.30000000000000004，因此判断会得到false 解决：设置误差范围，即计算结果在误差范围内即可 1234var a = 0.1;var b = 0.2;var c = 0.3;var isEqual = (a + b -c) &lt; Number.EPSISON; ES5 - polyfill 123if (!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2, -52);&#125; 体系缺漏显示与隐式类型转换显示：String(…), Number(…), Booolean(…)这种不带new的是显示类型转换；一元运算符：+XX 和 !XX 也是显式转换（注意：!XX不仅转类型，且将其值的布尔类型值反转，因此 !!XX 是合理的显示）隐式： 易错点~~和Math.floor()注意点：正数时候结果相同；但是负数时候则不同1234567// 正数Math.floor(9.9); // &gt; 9~~9.9 // &gt; 9// 负数Math.floor(-9.9); // &gt; -10~~-9.9 // -9 ### 关于JSON.stringify()使用的注意事项 parseInt语法：parseInt(string[, radix])，如果没有第二个参数，默认为10。同时如果第一个参数不是字符串，则会将其转为字符串再做操作1234567891011// 示例1parseInt(new String(42)); // &gt; 42, 将String对象拆封再将数字转为字符串，再做处理// 示例2var a = &#123; num: 2, toString () &#123; return String(this.num * 2); &#125;&#125;;parseInt(a); // &gt; 4 [] + {}和{} + [] TODO: 《中》 5.1.312[] + &#123;&#125; // &gt; [object object]&#123;&#125; + [] // &gt; 0 代码片段~和indexOf检查字段存在性 ~a按位非运算符: ~x 等同于 -(x+1) indexOf语法： stringObject.indexOf(searchvalue[,fromindex])，如果没有第二个参数，则从0开始检测searchValue出现的位置(从0开始)，如未找到，则返回-1 通常我们在检测字段时使用 &gt;= 0 和 == -1 做判断，这样的写法不是很好，称为’抽象渗透’，意思是在代码中暴漏了底层的实现细节(见书本p61) 解决：~(str.indexOf(target))作为判断的代码片段，当未检测到即返回的结果是-1时，~-1的结果为0，隐式转为布尔型，判断结果同为false12345var str = 'hello world';var target = 'roy';if (~str.indexOf(target)) &#123; // false console.log('find it');&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frist Page]]></title>
    <url>%2F2018%2F05%2F18%2FFrist%20Page%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server more Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
